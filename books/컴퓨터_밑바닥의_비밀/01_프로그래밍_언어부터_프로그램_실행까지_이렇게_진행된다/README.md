# 01. 프로그래밍 언어부터 프로그램 실행까지, 이렇게 진행된다.

첫 장에서는 프로그래머가 코드를 작성, 실행할 때 어떤 일이 일어나는지를 살펴본다.



**프로그래밍 언어**

![image-20250127193050981](C:\Users\home\AppData\Roaming\Typora\typora-user-images\image-20250127193050981.png)

- 단순한 프로그래머가 컴퓨터에 명령을 내리는 도구
- 컴퓨터 과학에서 프로그래밍 언어는 아주 작은 부분을 담당



> 🤔 내가 만든 코드는 어떻게 동작해서 실행될까?



## 1. 여러분이 프로그래밍 언어를 발명한다면?

1. CPU가 개발됨

- 간단한 스위치로 복잡한 불 논리(boolean logic)을 표현

![Golden Cpu With Binary Numbers Stock Photo - Download Image Now - Gold -  Metal, Artificial Intelligence, Gold Colored - iStock](https://media.istockphoto.com/id/901630160/photo/golden-cpu-with-binary-numbers.jpg?s=170667a&w=0&k=20&c=yATvDh6jwjXJ8klfFlQTz1B29jC4owj3WgcZGg8dmas=)



2. 최초의 프로그래머 <-> CPU 의사소통

- 천공 카드(punched carrd)를 이용해 컴퓨터 작업을 제어함
- CPU의 언어인 0, 1을 조합한 명령어를 작성
- 해당 형태는 **무슨 뜻인지 알아챌 수 없는 형태**

<img src="C:\Users\home\AppData\Roaming\Typora\typora-user-images\image-20250127193815018.png" alt="image-20250127193815018" style="zoom:50%;" />



3. 어셈블리어 등장

- CPU는 가산 명령어, 점프 명령어 등 겨우 몇가지 명령어만 실행할 수 있음
- 이를 인간이 이해할 수 있는 단어와 대응시킨 것이 어셈블리어
- **인간이 이해**할 수 있는 최초의 프로그래밍 언어가 탄생

> 🤔 어셈블리어의 어원?
>
> : Assembly + Language로서 명령어와 데이터를 "조립(Assembly)" 한 언어를 의미

```
sub $8, %rsp       # 스택 포인터(rsp)를 8바이트만큼 감소시킴. 스택 공간 확보 (주로 함수 호출 전에 사용).
mov $.LC0, %edi    # 문자열 리터럴(.LC0)의 주소를 edi 레지스터에 저장. 
                   # edi는 호출 규약에 따라 printf나 puts 같은 함수의 첫 번째 인자로 사용됨.
call puts          # puts 함수를 호출. edi에 저장된 문자열(.LC0)을 출력.
mov $0, %eax       # eax 레지스터에 0을 저장. 주로 함수의 리턴 값을 설정할 때 사용 (여기서는 0을 반환).
```



4. 여전히 저수준(low-level)인 어셈블리어

- CPU는 매우 원시적이라 데이터를 이동 후 간단한 연산, 그리고 또 이동과 같은 것만 할 수 있음
- "물 한잔 줘" 라는 표현을 이해하지 못해, 다음과 같이 어셈블리어처럼 저수준 언어로 표현해야함

```
오른쪽 다리를 내딛는다
멈춘다
왼쪽 다리를 내딛는다
멈춘다
앞의 걸음을 음수대 옆에 도착할 때까지 반복한다
물컵을 찾는다
오른손을 들어 올린다
물컵을 잡는다
수도꼭지로 이동한다
왼손을 뻗는다
수도꼭지를 연다
물이 아직 가득 차지 않았다면
계속 기다린다
물이 이미 가득 찼다면
수도꼭지를 잠근다
뒤로 180도 돈다
오른쪽 다리를 내딛는다
멈춘다
왼쪽 다리를 내딛는다
멈춘다
앞의 걸음을 돌아올 때까지 반복한다
```

- 인간의 추상적 표현을 CPU가 이해할 수 있는 구체적 구현으로 자동 변환이 필요해짐



5. 저수준 언어 번역을 위한 규칙 찾기

- 위에서 CPU가 이해할 수 있는 저수준 언어를 살펴보면 **규칙이 발견**됨
  - 규칙
    - statement : 단순한 동작 (예: 물컵을 찾는다, 왼손을 뻗는다, 수도꼭지를 연다, 등 ...)
    - if ... else ... : 조건에 따라 동작 (예: 물이 아직 가득 차지 않았다면, 물이 이미 가득 찼다면)
    - while : 반복 (예: ... 반복한다)
  - 이 규칙들을 표현하는 문장을 구문(syntax)라고 표현하기로 함
- statement 구문은 if | for | statement 가 재귀적으로 이루어져 있음
  - 이러한 재귀는 tree로 표현할 수 있으며 이를 **구문 트리(syntax tree)**라고 함

<img src="C:\Users\home\AppData\Roaming\Typora\typora-user-images\image-20250127200530906.png" alt="image-20250127200530906" style="zoom: 67%;" />



5. 컴파일러 : 프로그래밍 언어 번역가

- 구문 트리의 리프 노드(leap node)는 형태가 매우 간단해서 기계어로 번역하기 쉬움
- 그렇게 루트 노드(root node)까지 번역할 수 있게됨
- 이를 담당하는 번역 프로그램이 **컴파일러**임

<img src="C:\Users\home\AppData\Roaming\Typora\typora-user-images\image-20250127200716584.png" alt="image-20250127200716584" style="zoom:67%;" />

> 🤔 어셈블리어는 필요 없는거 아닌가?
>
> **더 세밀한 제어가 필요할 때**
>
> - 컴파일러는 고급 언어(C, Python 등)를 기계어로 바꿀 때, 알아서 최적화를 해줌
> - 그런데 어떤 작업에서는 세밀한 제어가 필요할 수 있음
>   - 예: CPU 레지스터나 메모리 주소를 직접 조작
>   - **어셈블리어를 쓰면 개발자가 기계어 수준에서 직접 제어**할 수 있음
>
> **특정 하드웨어에 맞춘 작업**
>
> - 어셈블리어는 특정 CPU 아키텍처(Intel, ARM 등)에 딱 맞춰진 언어
> - 하드웨어에 최적화된 코드를 작성하려면 어셈블리어가 유리함
>   - 예: 드라이버 개발, 임베디드 시스템
>
> **디버깅과 분석**
>
> - 기계어는 사람이 이해하기 어려워서, **어셈블리어로 변환**해서 디버깅하거나 해커가 역분석할 때 사용됨
> - 시스템에서 오류가 났을 때, 어셈블리어를 보면 어떤 문제가 발생했는지 더 정확히 알 수 있음



6. 새로운 문제점

- 각양각색의 CPU마다 컴파일된 실행 파일(기계 명령어 모음)은 다른 CPU에서 실행할 수 없음
  - 예: x86 플랫폼에서 컴파일 된 실행 파일은 ARM 플랫폼에서 실행 불가
- 플랫폼마다 코드를 다시 컴파일하게 됨
  - 이게 문제인 이유:
    1. 시간이 오래 걸림: 프로그램을 새로 컴파일해야 하는 작업은 귀찮고 오래 걸림
    2. 관리 복잡: 여러 CPU에 맞게 각각 컴파일된 파일(바이너리)을 따로 관리해야함
    3. 배포 문제: 사용자가 어떤 CPU를 쓰는지 모르니까, 모든 버전을 만들어서 제공해야함



7. 가상 머신(virtual machine)의 등장

- 표준 명령어 집합을 정의 후 각 CPU 마다 상응하는 프로그램이 만들어짐

> 🤔 언어에 따라 바로 바로 번역하기도 함
>
> **C와 Java의 차이 요약**
>
> | **C 언어**                         | **Java**                                     |
> | ---------------------------------- | -------------------------------------------- |
> | **기계어로 바로 번역**             | **바이트코드로 변환 → VM에서 실행**          |
> | CPU마다 **다시 컴파일** 필요       | 한 번 바이트코드로 만들면 모든 CPU에서 실행  |
> | 실행 속도가 빠름 (CPU 직접 실행)   | 실행 속도는 조금 느림 (VM이 중간에서 처리)   |
> | 효율적이지만 플랫폼 간 호환성 부족 | 호환성이 뛰어남 (VM 덕분에 모든 플랫폼 지원) |

- 이를 인터프리터(interpreter)라는 별명으로도 부름

> 🤔 VM과 인터프리터는 다른데..?
>
> 가상 머신(VM)"과 "인터프리터"를 같은 맥락에서 설명한 이유는, **둘 다 플랫폼 독립성**을 제공하기 때문으로 보임
>
> **VM과 인터프리터의 차이**
>
> | **구분**      | **VM(가상 머신)**                            | **인터프리터**                       |
> | ------------- | -------------------------------------------- | ------------------------------------ |
> | **동작 방식** | 플랫폼 독립적인 중간 코드(바이트코드)를 실행 | 소스 코드를 한 줄씩 읽고 바로 실행   |
> | **목적**      | 플랫폼 독립성 제공 (한 번만 컴파일)          | 빠르게 실행, 테스트 및 디버깅에 유리 |
> | **성능**      | 인터프리터보다 빠름                          | VM보다 느림                          |
> | **예시**      | Java의 JVM, .NET의 CLR                       | Python, JavaScript, PHP              |



## 2. 컴파일러는 어떻게 작동하는 것일까?

1. 어휘 분석(lexical analsis)

- 소스 파일의 각 항목을 잘게 쪼갠 후 각 항목이 가지고 있는 추가 정보를 함께 묶어 **토큰** 단위로 관리함
- 예시 코드

  ```c#
   int a = 1;
   int b = 1;
   
   while (a < b)
   {
     b = b - 1;
   }
  ```

- 토크나이징 결과

  ```
  T_Keyword    int
  T_Identifier a
  T_Assign     =
  T_Integer    1
  T_Semicolon  ;
  
  T_Keyword    int
  T_Identifier b
  T_Assign     =
  T_Integer    1
  T_Semicolon  ;
  
  T_Keyword    while
  T_LParen     (
  T_Identifier a
  T_LessThan   <
  T_Identifier b
  T_RParen     )
  
  T_LBrace     {
  T_Identifier b
  T_Assign     =
  T_Identifier b
  T_Minus      -
  T_Integer    1
  T_Semicolon  ;
  T_RBrace     }
  ```

  


2. 구문 분석(syntax analsis)

- 컴파일러에 정의된 구문 규칙에 따라 **토큰을 해석**하여 **구문 트리(syntax tree)** 형태로 만듦
- 이 과정에서 토큰이 유효하지 않으면 **문법 오류(syntax error)**를 발생시킴



3. 의미 분석(semantic analysis)

- 구문 트리에 이상이 없는지 확인
- 예 : 정수에 문자열을 더하는지, 비교 기호 좌우 값 형식이 다른지



4. 중간 코드(Itermediate Representation Code, IR Code) 생성

- 구문 트리 탐색 결과를 좀 더 다듬어진 형태 코드로 생성

```
  a = 1
  b = 2
  goto B
A: b = b - 1
B: if a < b goto A
```



5. 어셈블리어 생성

- 중간 코드를 어셈블리어 코드로 변환한다. 
- 예: x86 기반 어셈블리어 

```
  movl $0x1, -0x4(%rbp)    # a = 1
  movl $0x2, -0x8(%rbp)    # b = 2
  jmp B                    # goto B

A:                         # A 레이블
  movl -0x8(%rbp), %eax    # eax = b
  subl $0x1, %eax          # eax = eax - 1 (b - 1)
  movl %eax, -0x8(%rbp)    # b = eax
  jmp B                    # goto B

B:                         # B 레이블
  movl -0x4(%rbp), %eax    # eax = a
  cmpl -0x8(%rbp), %eax    # compare a, b
  jl A                     # if a < b, jump to A
```



6. 어셈블리어 코드를 기계어로 변환