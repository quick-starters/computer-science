## 4.1 이 작은 장난감을 CPU라고 부른다.

### 4.1.1 위대한 발명

<img src="/Users/moonjihyun/Documents/컴퓨터 밑바닥의 비밀/4.1/images/image-20250318123202574.png" alt="image-20250318123202574" style="zoom:25%;" />

**트랜지스터(Transistor)** : 단자한쪽에 전류를 흘리면 나머지 단자 두 개에 전류가 흐르게 하거나 흐르지 못하게 함.

우리가 작성한 프로그램 -> 최종적으로 트랜지스터의 개폐 작업으로 완성됨



### 4.1.2 논리곱, 논리합, 논리부정

- 스위치 두개가 동시에 켜질때만 전류가 흐르고 등이 켜짐 = 논리곱 (AND(^) 게이트)
- 두 스위치 중 하나라도 켜져있으면 전류가 흐를수있으며 등이 켜짐 = 논리합 (OR(+) 게이트)
- 스위치를 닫으면 전류가 흘러 등이 켜지지만, 스위치를 열면 전류가 흐르지 않고 등이 꺼짐 = 논리부정 (NOT 게이트)



### 4.1.3 도는 하나를 낳고, 하나는 둘을 낳고, 둘은 셋을 낳으며, 셋은 만물을 낳는다.

논리적 완전성 = 충분한 논리곱, 논리합, 논리부정 게이트로 모든 논리 함수를 표현할 수 있다. (이외에는 어떤 논리 게이트 회로도 필요하지 않음)

=> 이 세 게이트는 논리적으로 완전하다고 간주함.



### 4.1.4 연산 능력은 어디에서 나올까?

2진법의 덧셈 연산

- 0 + 0 = 0, carry(자리올림수) = 0
- 0 + 1 = 1, carry(자리올림수) = 0
- 1 + 0 = 1, carry(자리올림수) = 0
- 1 + 1 = 0, carry(자리올림수) = 1



모두 다 1일 때 자리올림수가 1 => 논리곱 게이트

두 값이 같으면 결과가 0, 다르면 1 => 배타적 논리합



2진수 덧셈은 논리곱 게이트 하나와 배타적 논리합 게이트 하나를 통해 구현할 수 있다.

<img src="/Users/moonjihyun/Documents/컴퓨터 밑바닥의 비밀/4.1/images/image-20250318124838256.png" alt="image-20250318124838256" style="zoom: 33%;" />

ALU: CPU에서 전문적으로 계산을 담당하는 모듈. 산술 논리 장치



### 4.1.5 신기한 기억 능력

앞서 설계한 조합 회로는 연산 능력은 있지만 정보를 저장할 수 없어서 입력을 기반으로 출력을 내보내기만 한다.



<img src="/Users/moonjihyun/Documents/컴퓨터 밑바닥의 비밀/4.1/images/image-20250318125834139.png" alt="image-20250318125834139" style="zoom:63%;" />

부정 논리곱 게이트 두개를 조합한 기억회로. 

- 부정 논리곱 게이트 

  - 논리곱 게이트, 논리부정 게이트의 조합

  - 먼저 논리곱 연산을 처리한 후, 논리부정 연산을 처리함. 

    - 1과 0을 입력했다면 논리곱 연산의 결과는 0, 이를 다시 논리부정 연산하면 1

  - 부정 논리곱 게이트의 출력은 다른 부정 논리곱 게이트의 입력이다.

  - S 와 R에 1을 입력하면 이 회로는 다음 두 가지 상태를 가짐

    - 단자 a가 1이면, B = 0, A = 1, b = 0 
    - 단자 a가 0이면, B = 1, A = 0, b = 1

    - 이 외 다른 상태를 가지지 않으므로, 단자 a를 회로의 출력으로 사용함.

  - S단자가 0이라면, a는 항상 1이 됨 (0 ^ a != 1이기 때문)

    - B = 0, A = 1, b = 0
    - 회로에 1이 저장되어 있다고 표현

  - R단자가 0이라면, a는 항상 0이됨.
    - 회로에 0이 저장되어 있다고 표현



실제로 저장하는데 필요한 입력은 비트 하나이기 때문에 회로를 아래와 같이 수정함. (WE(Write Enable) 단자는 저장 여부를 선택하는데 사용됨)

<img src="/Users/moonjihyun/Documents/컴퓨터 밑바닥의 비밀/4.1/images/image-20250318131351463.png" alt="image-20250318131351463" style="zoom: 67%;" />

D단자가 0이면 전체 회로가 저장하는 것은 0.

D단자가 1이면 전체 회로가 저장하는 것은 1.

=> 위 회로가 1비트를 저장할 수 있는 사물함



### 4.1.6 레지스터와 메모리의 탄생

더 많은 비트를 저장하기 위해서는 위 논리 회로를 복제하여 비트수만큼 붙여 넣으면 된다.

이러한 조합회로를 **레지스터**라고 부른다.



더 많은 정보를 저장하고 주소 지정을 제공하기 위해 더 복잡하게 구축된 회로 = 메모리

(8비트를 1바이트로 규정하고, 각각의 바이트가 자신의 번호를 받음. 부여된 번호를 이용하여 회로에 저장된 정보를 읽음)



회로는 전원이 연결되어있는 한 정보를 저장할 수 있지만 전원이 끊기면 저장된 정보는 사라진다. => 메모리가 전원이 꺼지면 더 이상 데이터를 저장할 수 없는 이유



### 4.1.7 하드웨어 아니면 소프트웨어? 범용 장치

모든 논리 함수를 논리곱, 논리합, 논리부정 게이트를 사용해서 구현하는 것은 비현실적임.

(요리사 = 하드웨어, 레시피 = 소프트웨어)

모든 연산 논리를 반드시 회로같은 하드웨어로 구현할 필요 역시 없다.

하드웨어는 가장 기본적인 기능만 제공하고, 모든 연산 논리는 가장 기본적인 기능을 이용하여 소프트웨어로 표현 => 하드웨어를 통해 서로 다른 소프트웨어를 제공하여 새로운 기능 구현 가능



=> 컴퓨터가 범용 연산 장치라고 하는 이유 (앨런 튜링의 제안)



### 4.1.8 하드웨어의 기본 기술: 기계 명령

레시피 = 기계명령어

CPU는 연산 능력만 제공하고, 프로그래머가 피연산자를 제공

CPU 표현 방식은 명령어 집합을 이용하여 구현



### 4.1.9 소프트웨어와 하드웨어 간 인터페이스: 명령어 집합

명령어 집합 = CPU가 실행할 수 있는 명령어 + 각 명령어에 필요한 피연산자

<img src="/Users/moonjihyun/Library/Application Support/typora-user-images/image-20250318193234704.png" alt="image-20250318193234704" style="zoom:50%;" />

16비트로 구성된 명령어
- 처음 4비트는 CPU에 수행할 작업을 알려줌
  = 기계 명령어를 2^4개, 즉 16개 설계할 수 있음
  - 16개가 바로 명령어 집합이며, 명령어 집합은 프로그래머에게 CPU가 무엇을 할 수 있는지, 어떻게 CPU를 이용하여 일을 해야 하는지 알려줌.

시스템 계층 관점: 명령어 집합은 소프트웨어와 하드웨어가 만나는 곳이자 소프트웨어와 하드웨어가 서로 통신하는 인터페이스

고급프로그래밍 언어-> 기계 명령어로 변환하는 도구 : 컴파일러 




### 4.1.10 회로에는 지휘자가 필요하다.
1 + 1을 한다고 가정, 가산기가 작동할 때 R1과 R2가 반드시 1을 저장하는 것을 어떻게 보장할 수 있을까? 
즉, 각 부분의 회로가 함께 작업할 수 있도록 조정하거나 동기화하려면 어떻게 해야 할까?
클락 신호가 전압을 변경할 때마다 전체 회로의 각 레지스터, 즉 전체 회로 상태가 갱신된다. 따라서 클락신호를 통해 전체 회로가 함께 동작하도록 할 수 있다.

cpu의 클락 주파수는 높을수록 CPU가 1초에 더 많은 작업을 할 수 있다.



### 4.1.11 큰일을 해냈다, CPU가 탄생했다!
CPU = 중앙 처리 장치 = 프로세서 = 산술 논리 장치 + 레지스터 + 클락 신호 



## 4.2 CPU는 유휴 상태일 때 무엇을 할까?

### 4.2.1 컴퓨터의 CPU 사용률은 얼마인가?
현재 시스템에 많은 프로세스가 실행 중이더라도, 기본적으로 아무 작업을 하지 않고 대기 상태임.

### 4.2.2 프로세스 관리와 스케줄링
세부 정보 탭을 열어 보면 System Idle Process 항목이 대부분의 CPU 사용률을 차지.

프로세스 스케줄링: 운영체제는 프로세스에 우선순위를 할당하고, 우선순위에 따라 스케줄러(scheduler) 가 스케줄링을 할 수 있도록 대기열에 프로세스를 넣음. 



### 4.2.3 대기열 상태 확인: 더 나은 설계

```
if (queue.empty()) {
	do_something();
}
```

커널은 if문이 많기 때문에 위와 같은 코드는 복잡해질 수 있음
대기열을 가득 채워 항상 실행가능한 프로세스를 찾을 수 있도록 하면 예외처리를 하지 않아도 됨.
(연결리스트에서 감시자 노드를 사용하는 이유 => null 판단 로직을 제거해도 됨.)

<img src="/Users/moonjihyun/Library/Application Support/typora-user-images/image-20250318193352407.png" alt="image-20250318193352407" style="zoom:50%;" />

유휴작업 프로세스가 앞서 말한 System Idle process

시스템에 스케줄링 가능한 프로세스가 없을 때 스케줄러는 이 유휴 프로세스를 꺼내서 실행. (이때 유휴 프로세스는 항상 준비 완료 상태에 있으며 우선순위는 가장 낮다)

### 4.2.4 모든 것은 CPU로 돌아온다
halt 명령어
- 정지를 의미
- CPU 내부의 일부 모듈을 절전 상태로 전환하여 전력 소비를 크게 줄임.
- 절전 상태를 가급적 유지하도록 순환에 배치함.
- 특권명령이기 때문에 커널상태에서 CPU로만 실행 가능
- 시스템 내 더 이상 실행할 준비가 완료된 프로세스가 없다는 것

suspend 명령어
- 프로세스 일시 중지
- sleep 같은 함수를 호출을 통해 해당 함수를 호출한 프로세스만 일시 중지
- 다른 프로세스가 여전히 실행 상태라면 CPU는 유휴 상태로 진입할 수 없음.

 ### 4.2.5 유휴 프로세스와 CPU의 저전력 상태

스케줄링 가능한 프로세스가 더 이상 존재하지 않으면 스케줄러가 유휴 프로세스를 실행=> 순환 구조에서 계속 halt 명령어가 실행됨 (CPU 저전력 상태 돌입)

```
while (1) {
	while (!need_resched()) {
		cpuidle_idle_call();
	}
}
```

cpuidle_idle_call 함수는 최종적으로 halt 명령어를 실행



### 4.2.6 무한 순환 탈출: 인터럽트
위 코드 내부에 탈출 구문이 없는데 어떻게 빠져나왔을까?

1. 일정 시간마다 타이머 인터럽트 생성
2. CPU는 인터럽트 신호를 감지하고, 운영 체제 내부의 인터럽트 처리 프로그램을 실행. 
3. 인터럽트 처리 함수에서는 프로세스가 실행된 준비가 되었는지 판단
- 준비가 되었다면 중단되었던 프로세스를 계속 실행.
- 준비되어 있지 않았다면 프로세스를 임시 중지시키고, 스케줄러는 준비 완료 상태인 다른 프로세스를 스케줄링 

유휴 프로세스를 예로 들면, 유휴 프로세스가 타이머 인터럽트로 일시 중지되면 인터럽트 처리 함수는 시스템에 준비 완료된 프로세스가 있는지 확인하고, 없다면 유휴 프로세스를 계속 실행



## 4.3 CPU는 숫자를 어떻게 인식할까?

컴퓨터 시스템이 2진법인 이유는 컴퓨터의 저수준 계층이 각각 켜고 끄는 스위치인 트랜지스터로 구성되어 있기 때문



### 4.3.1 숫자 0과 양의 정수

- 아라비아숫자 : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
  - 위치기수법 : 값과 숫자의 위치가 직접적인 관계가 있음

- 2진법 역시 위치 기수법 사용

  - 5 = 1 * 2^2 + 0 * 2^1 + 1 * 2^0

  - 비트 k개를 사용하면 정수 k개를 나타낼 수 있음.
  - `0` ~ `2^k - 1` (k =8 이라고 가정하면 0 ~ 255, 부호없는 정수일 경우)



### 4.3.2 부호 있는 정수

최상위 비트가 정수 부호를 결정. 0 => 양수, 1 => 음수



### 4.3.3 양수에 음수 기호를 붙이면 바로 대응하는 음수: 부호 - 크기 표현

0010 = +2

1010 = -2

=> 부호-크기 표현이라고 한다.

1000 = -0 이 되는 문제가 발생



### 4.3.4 부호-크기 표현의 반전: 1의 보수

0010 = +2

1101 = -2 (+2 값을 완전히 반전)

=> 1의 보수

1111 = -0 이 되는 문제 여전히 발생.



### 4.3.5 간단하지 않은 두 수 더하기

2 + (-2)

- 부호-크기 방식 = 0010 + (1010) = 1100 = -4 (모순된 결과)
- 1의 보수 방식 = 0010 + 1101 = 1111 = -0 (모순되진 않음)



### 4.3.6 컴퓨터 친화적 표현 방식: 2의 보수

A + (-A) = 0 이면서 동시에 0을 표현할 때 2진법에서 0000이라는 표현 한가지만 존재하는 방법이 필요



A = 2라고 가정, 2 + (-2) = 0000

2는 명확하게 0010, -2는 최상위 비트가 1인 것만 확정

=> 0010 + 1??? = 0000

=> -2 = 1110

(2의 보수는 반대 + 1 = 1101 + 0001)



```tex
0000 = 0
0001 = 1
...
1000 = -8
...
1111 = -1
```



-1 + 1 = 1111 + 0001 = 10000 (자리올림수 발생)

=> 가산기가 계산을 수행할 때 숫자 부호에 전혀 신경쓸 필요가 없기 때문에 현대식 컴퓨터 시스템에서는 2의 보수를 사용

=> 1의 보수로 표현한 양수에 1을 더하면 2의 보수에서 대응하는 음수가 됨.



### 4.3.7 CPU는 정말 숫자를 알고 있을까?

2의 보수 표현방식의 계산 과정 

- 0010 + 1110 = 10000 

가산기는 이 과정에서 숫자가 양수인지, 음수인지 전혀 신경쓰지 않음

0010이라는 숫자의 의미조차 이해하지 못하지만, 두 비트의 배타적 논리합 연산이 덧셈이며, 두 비트의 논리곱 연산이 자리올림수라는 것만 알고 있음.

=> 결과값의 해석은 소프트웨어가 하는 것

CPU는 인간 개념을 이해하지 못하며, 인간이 제어해서 주어진 작업을 처리할 뿐이다.



