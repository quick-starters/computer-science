## 2.8 높은 동시성과 고성능을 갖춘 서버 구현

### 2.8.1 다중 프로세스

초기 형태 기술 : 병행 처리 방식의 다중 프로세스를 사용

리눅스에서 fork 방식을 이용해서 여러 자식 프로세스를 생성. 

- `사용자 요청` ---수신---> `부모프로세스` ---처리---> `자식프로세스`
- 각 요청에 대응하는 프로세스 존재

- 장점
  - 프로그래밍이 간단하여 이해하기 쉬움
  - 프로세스간 영향 x
  - 다중 코어 리소스를 최대한 활용 가능
- 단점
  - 프로세스 간 서로 통신이 필요할 때 다소 복잡하며, 프로세스 통신 작동 방식을 사용해야 함.
  - 프로세스를 생성할 때의 부담이 상대적으로 크고, 프로세스의 빈번한 생성과 종료로 시스템 부담 증가



### 2.8.2 다중 스레드

프로세스 주소 공간을 공유하는 스레드를 통해 구현하는 방식

- 장점
  - 별도의 통신 작동 방식을 사용할 필요가 없음
  - 스레드 안전이 보장된다는 전제하에 메모리를 직접 읽어서 데이터를 얻을 수 있음
  - 매우 가벼우며, 생성과 종료에 드는 부담이 적음
  - 스레드가 블로킹되더라도 다른 스레드에는 영향을 미치지 않음
  - 사용자 규모가 크지 않은 경우 다중 스레드로 충분히 처리 가능

- 단점
  - 스레드에 문제가 발생돼서 강제 종료되면, 같은 프로세스를 공유하는 모든 스레드와 프로세스가 한꺼번에 강제종료됨
  - 여러 스레드가 동시에 공유 리소스의 데이터를 읽고 쓸수 없음 (스레드 안전 문제 -> 상호 배제 고려, 교착상태 발생)



### 2.8.3 이벤트 순환과 이벤트 구동

이벤트 기반의 동시성을 이용한 이벤트 기반 프로그래밍

이벤트 기반 프로그래밍의 두가지 요소

- 이벤트 (대부분 입출력에 관계됨. 서버에서 이벤트는 사용자 요청)
- 이벤트를 처리하는 함수 (이벤트 핸들러)



이벤트가 도착하면 이벤트 유형을 확인해서 해당 유형을 처리하는 이벤트 핸들러를 호출 



`이벤트`  `이벤트`  `이벤트`  -> (이벤트 순환) -> handler()



- 수도코드로 표현된 이벤트 순환

```c++ while (true)
while (true) // 이벤트 순환
{
  event = getEvent(); // 이벤트 수신 대기
  handler(event); // 이벤트 처리
}
```



1) GetEvent 함수로 어떻게 여러 이벤트를 가져올 수 있을까
2) 이벤트를 처리하는 handler 함수가 반드시 이벤트 순환과 동일한 스레드에서 실행되어야 할까?



### 2.8.4 첫번째 문제 : 이벤트 소스와 입출력 다중화

리눅스와 유닉스 : 모든 것이 파일로 취급됨.

프로그램은 모두 파일 서술자를 사용하여 입출력 작업을 실행 (소켓도 동일)



사용자 연결이 열개고, 이에 대응하는 소켓 서술자가 열개 있는 서버가 데이터를 수신하려고 대기중이라고 가정하면 가장 간단하게 다음과 같이 처리할 수 있음

```c++
recv(fd1, buf1); // 문제점: 첫번째 사용자가 데이터를 보내지 않는 한 반환되지 않으므로 서버가 두번째 사용자를 처리할 수 없음
recv(fd2, buf2);
recv(fd3, buf3);
recv(fd4, buf4);
...
```



운영 체제에 다음 내용을 전달하는 작동방식 (입출력 다중화, epoll과 같은 방식)

```c++
// epoll 생성
epoll_fd = epoll_create();

// 서술자를 epoll이 처리하도록 지정
Epoll_ctl(epoll_fd, fd1, fd2, fd3, fd4 ...);

while (1)
{
  int n = epoll_wait(epoll_fd); // 이벤트 수신 대기, getEvent 함수와 동일한 역할
  for (i = 0; i < n; i++) 
  { 
  	// 특정 이벤트 처리
  }
}
```



### 2.8.5 두번째 문제: 이벤트 순환과 다중 스레드

이벤트 핸들러에 다음 두가지 특징이 있다고 가정해보자.

- 입출력 작업이 전혀 없다.
- 처리 함수가 간단해서 소요 시간이 매우 짧다.

=> 이벤트 핸들러와 이벤트 순환을 동일한 스레드에서 실행할 수 있다. (단일 스레드)



- 단일 스레드

  - 요청을 순차적으로 처리하더라도 시간이 거의 걸리지 않는다는걸 전제로 하기 때문에, 서버는 짧은 시간에도 많은 요청을 처리할 수 있음

  - 하지만 사용자 요청을 처리하는데 cpu시간을 많이 소모한다면? 
  - 시스템 응답이 느리며, 요청 a를 처리하는동안 요청 b에 대해 응답할 수 없음. => 다중 스레드의 필요

- 다중 스레드

  - 이벤트 핸들러는 이벤트 순환과 각각 독립적인 스레드에 배치됨.
  - 이벤트 순환은 요청을 수신하면 간단한 처리를 한 이후, 바로 각각의 작업자 스레드에 분배
  - 다중 스레드를 이용한 병행 실행은 다중 코어를 최대한 활용하여 요청 처리를 가속화함. (작업자 스레드를 스레드 풀로 구현하는 것도 가능)
  - 이러한 작업 방식을 반응자 패턴이라고 함.



### 2.8.6 카페는 어떻게 운영되는가:반응자 패턴

사장은 고객의 주문을 받고 요리사들에게 작업을 분배한다.

`고객` = 이벤트순환

`요리사` = 작업자 스레드

`카페운영 방식` = 반응자 패턴



### 2.8.7 이벤트 순환과 입출력

요청 처리 과정에 입출력 작업이 포함된다고 가정

- 입출력 작업에 대응하는 논블로킹 인터페이스가 있는 경우
  - 직접 논블로킹 인터페이스를 호출해도 스레드가 일시 중지 x
  - 인터페이스가 즉시 반환되므로 이벤트 순환에서 직접 호출 가능
- 입출력 작업에 블로킹 인터페이스만 있는 경우
  - 이벤트 순환 내에서 어떤 블로킹 인터페이스도 호출하면 안됨 (이벤트 순환 스레드가 일시중지될 수 있음 => 이벤트 순환이 멈춤)
  - 블로킹 입출력 호출이 포함된 작업은 작업자 스레드에 전달 (개발자는 Handler 함수에 집중)

<img src="/Users/moonjihyun/Documents/컴퓨터 밑바닥의 비밀/2.8/images/image-20250224200015492.png" alt="image-20250224200015492" style="zoom: 33%;" />

### 2.8.8 비동기와 콜백 함수

서버 기능이 점점 복잡해지면 하나의 사용자 요청을 처리하는 데 여러 서비스가 포함될 수 있음

서버는 일반적으로 원격 프로시저 호출(remote procedure call, RPC) 을 통해 통신함.

RPC는 일반 함수 호출하는 것처럼 네트워크로 통신할 수 있도록 함.



```c++
GetUserInfo(request, response); // 최하위 계층에서는 네트워크 통신을 수행할 수 있음
```

이에 대응하는 handler 함수

```
void handler(request)
{
	A;
	B;
	GetuserInfo(request, response); // 서버 A에 요청 (RPC 호출 = 블로킹 호출, 사용자가 응답하기 전에는 함수가 반환되지 않음)
	C;
	D;
	GetuserInfo(request, response); // 서버 B에 요청
	E;
	F;
	GetuserInfo(request, response); // 서버 C에 요청
	G;
	H;
}
```

- 장점

  - 코드가 명확하고 이해하기 쉬움

- 단점

  - 블로킹 호출로 인해 스레드가 일시 중지 될 수 있고 블로킹 호출이 여러번 발생하면 스레드가 빈번하게 중단될 수 있음

    => 작업자 스레드가 많은 시간을 사용자 응답을 기다리는데 소모하고, CPU가 실행할 수 있도록 준비 완료된 스레드가 많지 않은 상황이 될 수 있음

  - 스레드의 스케줄링과 전환에 대한 부담이 크게 증가, CPU 컴퓨팅 리소스가 불필요한 작업에 낭비됨



RPC 호출을 비동기 호출로 수정

```c++
GetUserInfo(request, callback); // 함수가 즉시 반환되지만, 사용자 응답에 대한 결과가 없을 수 있음
```



```c++
void handler_after_GetStorkInfo(response)
{
  G;
  H;
}

void handler_after_GetQueryInfo(response)
{
  E;
  F;
  GetStorkInfo(request, handler_after_GetStorkInfo); // 서버 c에 요청
}

void handler_after_GetUserInfo(response)
{
  E;
  F;
  GetQueryInfo(request, handler_after_GetQueryInfo); // 서버 b에 요청
}

void handler(request)
{
  A;
  B;
  GetUserInfo(request, handler_after_GetUserInfo); // 서버 a에 요청
}
```

=> 콜백 안에 콜백이 있으므로 사용자 서비스가 더 많아지면 관리가 불가능 함.



### 2.8.9 코루틴 : 동기 방식의 비동기 프로그래밍

프로그래밍 언어나 프레임워크가 코루틴을 지원하는 경우, handler함수가 코루틴에서 실행되도록 할 수 있음

handler함수의 코드는 동기적이지만, yield로 CPU 제어권을 반환하는 등 RPC 통신이 시작된 후 바로 호출되는 점은 다름

RPC호출 함수 또는 네트워크 데이터 전송 함수를 수정해야 yield로 CPU 제어권을 반환할 수 있음



- 스레드를 사용하는 블로킹 호출과 가장 큰 차이점
  - 코루틴이 일시중지 되더라도 작업자 스레드가 블로킹 X
  - 코루틴이 일시중지되면 작업자 스레드는 준비완료된 다른 코루틴을 실행하기 위해 전환됨
    -> 일시 중지된 코루틴에 할당된 사용자 서비스가 응답 후 처리결과를 반환하면 다시 준비 상태가 되어 스케줄링 차례가 돌아오길 기다림

코루틴을 통해 동기방식이지만 비동기 실행과 같은 효과를 얻을 수 있음

![image-20250224203448035](/Users/moonjihyun/Documents/컴퓨터 밑바닥의 비밀/2.8/images/image-20250224203448035.png)

1. Handler 함수를 코루틴에 담아 스케줄링과 실행을 위해 각 작업자 스레드에 배포.

2. 작업자 스레드는 코루틴을 획득한 후 진입함수인 handler 실행

3. 어떤 코루틴이 RPC 요청으로 CPU 제어권을 능동적으로 반환하면 작업자 스레드는 준비상태인 다른 코루틴 실행

=> 작업자 스레드의 블로킹을 막아서 시스템 리소스를 효율적으로 사용



### 2.8.10 CPU, 스레드, 코루틴

- 하드웨어 = cpu
  - CPU는 기계 명령어를 실행하여 컴퓨터를 움직임
- 커널 상태 = 스레드
  - 스레드는 커널상태 스레드라고도 하며, 커널로 생성되고 스케줄링을 함
  - 커널은 스레드 우선순위에 따라 CPU 연산 리소스 할당

- 사용자 상태 = 코루틴

  - 코루틴은 커널입장에서는 알수 없는 요소. 코루틴이 얼마나 많이 생성되든 커널은 이와 관계없이 스레드에 따라 CPU 시간 할당

  - 프로그래머는 스레드에 할당된 시간 내 실행할 코루틴을 결정할 수 있는데, 이는 스레드에 할당된 CPU시간을 사용자 상태에서 재차 할당하는 것에 해당 (사용자 상태 스레드)



cpu --실행--> 스레드 --실행--> 코루틴





## 2.9 컴퓨터 시스템 여행: 데이터, 코드, 콜백, 클로저에서 컨테이너, 가상머신까지



### 2.9.1 코드, 데이터, 변수, 포인터



함수 : 하나의 별칭으로 일련의 명령어 지칭

변수 : 별칭으로 데이터를 지칭

- 메모리 : 코드로 구성된 명령어 외에 명령어 동작에 필요한 데이터 저장
- 데이터 : 구조체의 인스턴스, 객체, 배열 등.. 



여러 변수를 사용하여 동일한 데이터를 참조할 수 있음.

- `포인터` : a, b, c 변수는 모두 같은 데이터를 참조하는데, C에서는 a, b, c 변수를 포인터라고 함. (=참조라고도 함)



### 2.9.2 콜백 함수와 클로저

- `일급 객체 함수` : 변수 여러개가 동일한 코드를 참조할 수 있음
  => 특정 언어에서 코드를 일반 변수를 다루듯이 처리할 수 있을 때 해당 코드를 일급 객체 함수라고 함.

함수가 다른 함수에 매개변수로 전달될 때 해당 함수를 콜백 함수라고 함

```
void bar(foo f) // f가 콜백 함수
{
	f();
}
```



콜백 함수는 정의와 호출을 서로 다른곳에서 함. 만약 콜백함수가 정의된 곳에서 선언된 데이터나 실행 시간 환경 등을 콜백 함수가 사용해야 하면?



- `클로저` : 콜백 함수를 일부 데이터와 한데 묶어 변수로 취급

```python
def add():
	b = 10
  
  def add_inner(x):
    return b + x
  
  return add_inner

f = add()
print(f(2))
```

add 함수에서 정의된 add_inner에서 b 변수와 사용자 매개변수 x(2) 를 사용함.

add_inner는 코드뿐만 아니라 실행 시간 환경인 B 변수를 묶어서 전달하는 클로저임



### 2.9.3 컨테이너와 가상머신 기술

`코루틴` : 어떤 함수가 CPU를 능동적으로 일시중지하고 다음에 함수가 다시 호출될 때 앞에서 중단된 지점에서 계속 실행하는 것이 가능한 함수

`스레드` : 함수의 일시 중지와 재개가 커널 상태에서 구현

`프로세스` : 스레드에 주소 공간처럼 종속된 실행시 리소스를 결합한 것





#### 운영체제 가상화

`컨테이너` : 라이브러리처럼 프로그램이 의존하는 실행환경과 함께 묶인 것 (일종의 가상화 기술로서 운영체제를 가상화 함)

- 운영체제에서 제공하는 기능을 통해 프로세스를 격리
- CPU, 메모리, 디스크에 대한 접근 제어
- 컨테이너에 포함된 프로세스가 전체 운영 체제 안에서 자기 자신의 프로세스만 존재하고 있다고 가정할 수 있게 함.
- ex. 도커
- 운영 체제 계층 수준에서 소프트웨어 리소스를 가상화함. 



#### 하드웨어 가상화

`하이퍼바이저` :  가상머신 감시자. 

- 하드웨어를 추상화
- 하드웨어 리소스를 가상 컴퓨터 여러개로 나누고 그 위에서 운영체제 실행
- 해당 운영체제는 하드웨어의 리소스를 가져와 사용할 수 있는데, 이런 작업을 하는 소프트웨어가 바로 가상머신 감시자. (=하이퍼바이저)

- 가상 머신 감시자에서 실행되는 운영체제가 가상머신 (하드웨어 리소스를 독점한다고 간주)
- ex. VMware, Hyper-V, KVM, Xen



VM은 시스템 수준의 격리가 필요할 때, 컨테이너는 애플리케이션 수준의 격리가 필요할 때 유용

